/*
Copyright (c) Daybrush
name: croact
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/croact.git
version: 1.0.4
*/
'use strict';

var utils = require('@daybrush/utils');
var listDiffer = require('@egjs/list-differ');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function fillKeys(keys) {
  var index = 0;
  return keys.map(function (key) {
    return key == null ? "$compat".concat(++index) : "".concat(key);
  });
}
function flat(arr) {
  var arr2 = [];
  arr.forEach(function (el) {
    arr2 = arr2.concat(utils.isArray(el) ? flat(el) : el);
  });
  return arr2;
}
function fillProps(props, defaultProps) {
  if (!defaultProps) {
    return props;
  }
  for (var name_1 in defaultProps) {
    if (utils.isUndefined(props[name_1])) {
      props[name_1] = defaultProps[name_1];
    }
  }
  return props;
}
function isDiff(a, b) {
  if (a === b) {
    return false;
  }
  for (var i in a) {
    if (!(i in b)) {
      return true;
    }
  }
  for (var i in b) {
    if (a[i] !== b[i]) {
      return true;
    }
  }
  return false;
}
function getAttributes(props) {
  var className = props.className,
    otherProps = __rest(props, ["className"]);
  if (className != null) {
    otherProps.class = className;
  }
  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}
function splitProps(props) {
  var attributes = {};
  var events = {};
  for (var name_2 in props) {
    if (name_2.indexOf("on") === 0) {
      events[name_2] = props[name_2];
    } else {
      attributes[name_2] = props[name_2];
    }
  }
  return [attributes, events];
}
function findContainerNode(provider) {
  if (!provider) {
    return null;
  }
  var base = provider.b;
  if (utils.isNode(base)) {
    return base;
  }
  return findContainerNode(provider.c);
}
function removeNode(node) {
  var parentNode = node.parentNode;
  if (parentNode) {
    parentNode.removeChild(node);
  }
}
function executeHooks(hooks) {
  hooks.forEach(function (hook) {
    hook();
  });
}
function renderFunctionComponent() {
  return this.constructor(this.props, this.context);
}

var hooksIndex = 0;
var Provider = /*#__PURE__*/function () {
  function Provider(
  /**
   * Type
   */
  t,
  /**
   * Depth
   */
  d,
  /**
   * Key
   */
  k,
  /**
   * index
   */
  i,
  /**
   * Container
   */
  c,
  /**
   * Ref
   */
  ref,
  /**
   * Props
   */
  ps) {
    if (ps === void 0) {
      ps = {};
    }
    this.t = t;
    this.d = d;
    this.k = k;
    this.i = i;
    this.c = c;
    this.ref = ref;
    this.ps = ps;
    this.typ = "prov";
    /**
     * providers
     */
    this._ps = [];
    /**
     * Contexts
     */
    this._cs = {};
    /**
     * Whether to hydrate
     */
    this._hyd = null;
    /**
     * is self render
     */
    this._sel = false;
  }
  var __proto = Provider.prototype;
  __proto.s = function () {
    return true;
  };
  /**
   * Update
   */
  __proto.u = function (hooks, contexts, nextElement, nextState, isForceUpdate) {
    var self = this;
    var currentDepth = self.d;
    var scheduledContexts = utils.getValues(contexts).filter(function (context) {
      return context.$_req;
    });
    var scheduledSubs = flat(scheduledContexts.map(function (context) {
      return context.$_subs;
    }));
    var isContextUpdate = utils.find(scheduledSubs, function (provider) {
      return provider.d === currentDepth;
    });
    if (self.b && !utils.isString(nextElement) && !isForceUpdate && !self.s(nextElement.props, nextState) && !isContextUpdate) {
      var nextChildSubs = scheduledSubs.reduce(function (childs, sub) {
        var depth = sub.d;
        if (childs[0]) {
          if (childs[0].d === depth) {
            childs.push(sub);
          }
        } else if (depth > currentDepth) {
          childs.push(sub);
        }
        return childs;
      }, []);
      nextChildSubs.forEach(function (child) {
        // provider.container!,
        // [provider],
        // [provider.original],
        // hooks,
        // provider._cs,
        // { ...self.state, ...self.$_state },
        // isForceUpdate,
        renderProviders(child, child._ps, [child.o], hooks, contexts, true);
      });
      return false;
    }
    self.o = nextElement;
    self.ss(nextState);
    // render
    var prevProps = self.ps;
    if (!utils.isString(nextElement)) {
      self.ps = nextElement.props;
      self.ref = nextElement.ref;
    }
    setCurrentInstance(this);
    self.r(hooks, contexts, self.b ? prevProps : {}, nextState);
    return true;
  };
  __proto.md = function () {
    this.rr();
  };
  __proto.ss = function () {
    return;
  };
  __proto.ud = function () {
    this.rr();
  };
  /**
   * register refs
   */
  __proto.rr = function () {
    var self = this;
    var ref = self.ref;
    var fr = self.fr;
    ref && ref(fr ? fr.current : self.b);
  };
  return Provider;
}();
function getCurrentInstance() {
  return Object.__CROACT_CURRENT_INSTNACE__;
}
function getHooksIndex() {
  return hooksIndex;
}
function setHooksInex(nextHooksIndex) {
  hooksIndex = nextHooksIndex;
}
function setCurrentInstance(provider) {
  Object.__CROACT_CURRENT_INSTNACE__ = provider;
  hooksIndex = 0;
  return provider;
}

var Component = /*#__PURE__*/function () {
  function Component(props, context) {
    if (props === void 0) {
      props = {};
    }
    this.props = props;
    this.context = context;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
    this.$_subs = [];
    this.$_cs = {};
  }
  var __proto = Component.prototype;
  __proto.render = function () {
    return null;
  };
  __proto.shouldComponentUpdate = function (props, state) {
    return this.props !== props || this.state !== state;
  };
  __proto.setState = function (state, callback, isForceUpdate) {
    var self = this;
    if (!self.$_timer) {
      self.$_state = {};
    }
    clearTimeout(self.$_timer);
    self.$_timer = 0;
    self.$_state = __assign(__assign({}, self.$_state), state);
    if (!isForceUpdate) {
      self.$_timer = window.setTimeout(function () {
        self.$_timer = 0;
        self.$_setState(callback, isForceUpdate);
      });
    } else {
      self.$_setState(callback, isForceUpdate);
    }
    return;
  };
  __proto.forceUpdate = function (callback) {
    this.setState({}, callback, true);
  };
  __proto.componentDidMount = function () {};
  __proto.componentDidUpdate = function (prevProps, prevState) {};
  __proto.componentWillUnmount = function () {};
  __proto.$_setState = function (callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_p;
    var isUpdate = renderProviders(provider.c, [provider], [provider.o], hooks, provider._cs, __assign(__assign({}, this.state), this.$_state), isForceUpdate);
    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }
      executeHooks(hooks);
      setCurrentInstance(null);
    }
  };
  return Component;
}();
var PureComponent = /*#__PURE__*/function (_super) {
  __extends(PureComponent, _super);
  function PureComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = PureComponent.prototype;
  __proto.shouldComponentUpdate = function (props, state) {
    return isDiff(this.props, props) || isDiff(this.state, state);
  };
  return PureComponent;
}(Component);

function createRef(defaultValue) {
  var refCallback = function (e) {
    refCallback.current = e;
  };
  refCallback.current = defaultValue;
  return refCallback;
}
function forwardRef(func) {
  func._fr = true;
  return func;
}

function createComponent(type, props, contextValue, self) {
  var _a;
  var base;
  if ((_a = type === null || type === void 0 ? void 0 : type.prototype) === null || _a === void 0 ? void 0 : _a.render) {
    base = new type(props, contextValue);
  } else {
    base = new Component(props, contextValue);
    base.constructor = type;
    if (type._fr) {
      self.fr = createRef();
      base.render = function () {
        return this.constructor(this.props, self.fr);
      };
    } else {
      base.render = renderFunctionComponent;
    }
  }
  base.$_p = self;
  return base;
}
var ComponentProvider = /*#__PURE__*/function (_super) {
  __extends(ComponentProvider, _super);
  function ComponentProvider(type, depth, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }
    var _this = _super.call(this, type, depth, key, index, container, ref, fillProps(props, type.defaultProps)) || this;
    _this.typ = "comp";
    /**
     * Update shift effects
     */
    _this._usefs = [];
    /**
     * Update effects
     */
    _this._uefs = [];
    /**
     * Destroy effects
     */
    _this._defs = [];
    return _this;
  }
  var __proto = ComponentProvider.prototype;
  __proto.s = function (nextProps, nextState) {
    var base = this.b;
    return base.shouldComponentUpdate(fillProps(nextProps, this.t.defaultProps), nextState || base.state) !== false;
  };
  __proto.r = function (hooks, contexts, prevProps) {
    var _a, _b;
    var self = this;
    var type = self.t;
    self.ps = fillProps(self.ps, self.t.defaultProps);
    var props = self.ps;
    var isMount = !self.b;
    var contextType = type.contextType;
    var base = self.b;
    var contextValue = contextType === null || contextType === void 0 ? void 0 : contextType.get(self);
    self._cs = contexts;
    if (isMount) {
      base = createComponent(type, props, contextValue, self);
      self.b = base;
    } else {
      base.props = props;
      base.context = contextValue;
    }
    var prevState = base.state;
    self._usefs = [];
    self._uefs = [];
    var template = base.render();
    if (((_b = (_a = template === null || template === void 0 ? void 0 : template.props) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length) === 0) {
      template.props.children = self.ps.children;
    }
    var nextContexts = __assign(__assign({}, contexts), base.$_cs);
    renderProviders(self, self._ps, template ? [template] : [], hooks, nextContexts);
    if (isMount) {
      self._uefs.push(function () {
        contextType === null || contextType === void 0 ? void 0 : contextType.register(self);
        base.componentDidMount();
      });
    } else {
      self._uefs.push(function () {
        base.componentDidUpdate(prevProps, prevState);
      });
    }
    hooks.push(function () {
      self._usefs.forEach(function (ef) {
        ef();
      });
      if (isMount) {
        self.md();
      } else {
        self.ud();
      }
      self._defs = self._uefs.map(function (ef) {
        return ef();
      });
    });
  };
  __proto.ss = function (nextState) {
    var base = this.b;
    if (!base || !nextState) {
      return;
    }
    base.state = nextState;
  };
  __proto.un = function () {
    var _a;
    var self = this;
    self._ps.forEach(function (provider) {
      provider.un();
    });
    var type = self.t;
    (_a = type.contextType) === null || _a === void 0 ? void 0 : _a.unregister(self);
    clearTimeout(self.b.$_timer);
    self._defs.forEach(function (def) {
      def && def();
    });
    self.b.componentWillUnmount();
  };
  return ComponentProvider;
}(Provider);

function diffAttributes(attrs1, attrs2, el) {
  var _a = diffObject(getAttributes(attrs1), getAttributes(attrs2)),
    added = _a.added,
    removed = _a.removed,
    changed = _a.changed;
  for (var name_1 in added) {
    el.setAttribute(name_1, added[name_1]);
  }
  for (var name_2 in changed) {
    el.setAttribute(name_2, changed[name_2][1]);
  }
  for (var name_3 in removed) {
    el.removeAttribute(name_3);
  }
}
function diffEvents(events1, events2, provier) {
  var _a = diffObject(events1, events2),
    added = _a.added,
    removed = _a.removed;
  for (var name_4 in removed) {
    provier.e(name_4, true);
  }
  for (var name_5 in added) {
    provier.e(name_5);
  }
}
function diffObject(a, b) {
  var keys1 = utils.getKeys(a);
  var keys2 = utils.getKeys(b);
  var result = listDiffer.diff(keys1, keys2, function (key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function (index) {
    var name = keys2[index];
    added[name] = b[name];
  });
  result.removed.forEach(function (index) {
    var name = keys1[index];
    removed[name] = a[name];
  });
  result.maintained.forEach(function (_a) {
    var index = _a[0];
    var name = keys1[index];
    var values = [a[name], b[name]];
    if (a[name] !== b[name]) {
      changed[name] = values;
    }
  });
  return {
    added: added,
    removed: removed,
    changed: changed
  };
}
function diffStyle(style1, style2, el) {
  var style = el.style;
  var _a = diffObject(style1, style2),
    added = _a.added,
    removed = _a.removed,
    changed = _a.changed;
  for (var beforeName in added) {
    var name_6 = utils.decamelize(beforeName, "-");
    style.setProperty(name_6, added[beforeName]);
  }
  for (var beforeName in changed) {
    var name_7 = utils.decamelize(beforeName, "-");
    style.setProperty(name_7, changed[beforeName][1]);
  }
  for (var beforeName in removed) {
    var name_8 = utils.decamelize(beforeName, "-");
    style.removeProperty(name_8);
  }
}
function getNativeEventName(name) {
  return name.replace(/^on/g, "").toLowerCase();
}
var ElementProvider = /*#__PURE__*/function (_super) {
  __extends(ElementProvider, _super);
  function ElementProvider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.typ = "elem";
    /**
     * Events
     */
    _this._es = {};
    /**
     * is svg
     */
    _this._svg = false;
    return _this;
  }
  var __proto = ElementProvider.prototype;
  __proto.e = function (name, isRemove) {
    var self = this;
    var events = self._es;
    var base = self.b;
    var eventName = getNativeEventName(name);
    if (isRemove) {
      utils.removeEvent(base, eventName, events[name]);
      delete events[name];
    } else {
      events[name] = function (e) {
        var _a, _b;
        (_b = (_a = self.ps)[name]) === null || _b === void 0 ? void 0 : _b.call(_a, e);
      };
      utils.addEvent(base, eventName, events[name]);
    }
  };
  __proto.s = function (nextProps) {
    return isDiff(this.ps, nextProps);
  };
  __proto.r = function (hooks, contextValues, prevProps) {
    var _a;
    var self = this;
    var isMount = !self.b;
    var nextProps = self.ps;
    if (isMount) {
      var containerNode = findContainerNode(self.c);
      var isSVG = false;
      if (self._svg || self.t === "svg") {
        isSVG = true;
      } else {
        isSVG = containerNode && containerNode.ownerSVGElement;
      }
      self._svg = isSVG;
      var element = (_a = self._hyd) === null || _a === void 0 ? void 0 : _a.splice(0, 1)[0];
      var type = self.t;
      if (element) {
        self._hyd = [].slice.call(element.children || []);
      } else {
        var doc = utils.getDocument(containerNode);
        if (isSVG) {
          element = doc.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = doc.createElement(type);
        }
      }
      self.b = element;
    }
    renderProviders(self, self._ps, nextProps.children, hooks, contextValues);
    var base = self.b;
    var _b = splitProps(prevProps),
      prevAttributes = _b[0],
      prevEvents = _b[1];
    var _c = splitProps(nextProps),
      nextAttributes = _c[0],
      nextEvents = _c[1];
    diffAttributes(prevAttributes, nextAttributes, base);
    diffEvents(prevEvents, nextEvents, self);
    diffStyle(prevProps.style || {}, nextProps.style || {}, base);
    hooks.push(function () {
      if (isMount) {
        self.md();
      } else {
        self.ud();
      }
    });
    return true;
  };
  __proto.un = function () {
    var self = this;
    var events = self._es;
    var base = self.b;
    for (var name_9 in events) {
      utils.removeEvent(base, name_9, events[name_9]);
    }
    self._ps.forEach(function (provider) {
      provider.un();
    });
    self._es = {};
    if (!self._sel) {
      removeNode(base);
    }
  };
  return ElementProvider;
}(Provider);

function findDOMNode(comp) {
  if (!comp || utils.isNode(comp)) {
    return comp;
  }
  var providers = comp.$_p._ps;
  if (!providers.length) {
    return null;
  }
  return findDOMNode(providers[0].b);
}
function findNodeProvider(provider) {
  if (!provider) {
    return;
  }
  if (provider.b && utils.isNode(provider.b)) {
    return provider;
  }
  var providers = provider._ps;
  if (!providers.length) {
    return null;
  }
  return findNodeProvider(providers[0]);
}
function createElement(type, props) {
  var children = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }
  var _a = props || {},
    key = _a.key,
    ref = _a.ref,
    otherProps = __rest(_a, ["key", "ref"]);
  return {
    type: type,
    key: key,
    ref: ref,
    props: __assign(__assign({}, otherProps), {
      children: utils.flat(children).filter(function (child) {
        return child != null && child !== false;
      })
    })
  };
}

var ContainerProvider = /*#__PURE__*/function (_super) {
  __extends(ContainerProvider, _super);
  function ContainerProvider(base, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    var _this = _super.call(this, "container", depth, "container", 0, null) || this;
    _this.typ = "container";
    _this.b = base;
    return _this;
  }
  var __proto = ContainerProvider.prototype;
  __proto.r = function () {
    return true;
  };
  __proto.un = function () {
    return;
  };
  return ContainerProvider;
}(Provider);
var TextProvider = /*#__PURE__*/function (_super) {
  __extends(TextProvider, _super);
  function TextProvider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.typ = "text";
    return _this;
  }
  var __proto = TextProvider.prototype;
  __proto.r = function (hooks) {
    var _a;
    var self = this;
    var isMount = !self.b;
    if (isMount) {
      var containerNode = findContainerNode(self.c);
      var b = (_a = self._hyd) === null || _a === void 0 ? void 0 : _a.splice(0, 1)[0];
      self.b = b || utils.getDocument(containerNode).createTextNode(self.t.replace("text_", ""));
    }
    hooks.push(function () {
      if (isMount) {
        self.md();
      } else {
        self.ud();
      }
    });
    return true;
  };
  __proto.un = function () {
    removeNode(this.b);
  };
  return TextProvider;
}(Provider);
function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function (p) {
    return utils.isString(p) ? null : p.key;
  });
  var keys1 = fillKeys(providers.map(function (p) {
    return p.k;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = listDiffer.diff(keys1, keys2, function (key) {
    return key;
  });
  result.removed.forEach(function (index) {
    providers.splice(index, 1)[0].un();
  });
  result.ordered.forEach(function (_a) {
    var from = _a[0],
      to = _a[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.b);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].b);
    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function (index) {
    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));
  });
  var changed = result.maintained.filter(function (_a) {
    _a[0];
      var to = _a[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = utils.isString(el) ? "text_".concat(el) : el.type;
    if (type !== childProvider.t) {
      childProvider.un();
      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }
    childProvider.i = to;
    return false;
  });
  return __spreadArray(__spreadArray([], result.added, true), changed.map(function (_a) {
    _a[0];
      var to = _a[1];
    return to;
  }), true);
}

function getNextSibiling(provider, childProvider) {
  var childProviders = provider._ps;
  var length = childProviders.length;
  for (var i = childProvider.i + 1; i < length; ++i) {
    var el = findDOMNode(childProviders[i].b);
    if (el) {
      return el;
    }
  }
  return null;
}
function createProvider(el, key, index, containerProvider) {
  var depth = containerProvider.d + 1;
  if (utils.isString(el) || utils.isNumber(el)) {
    return new TextProvider("text_".concat(el), depth, key, index, containerProvider, null, {});
  }
  var type = el.type;
  var providerClass = typeof type === "string" ? ElementProvider : ComponentProvider;
  return new providerClass(type, depth, key, index, containerProvider, el.ref, el.props);
}
function renderProviders(containerProvider, providers, children, updatedHooks, nextContexts, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var hyd = containerProvider._hyd;
  var updated = providers.filter(function (childProvider, i) {
    childProvider._hyd = hyd;
    return childProvider.u(updatedHooks, nextContexts, children[i], nextState, isForceUpdate);
  });
  if (containerProvider.typ === "container" && containerProvider._sel) {
    providers.forEach(function (provider) {
      var nodeProvider = findNodeProvider(provider);
      if (nodeProvider) {
        nodeProvider._sel = true;
      }
    });
  }
  containerProvider._hyd = null;
  var containerNode = findContainerNode(containerProvider);
  if (containerNode) {
    result.reverse().forEach(function (index) {
      var childProvider = providers[index];
      var el = findDOMNode(childProvider.b);
      if (!el) {
        return;
      }
      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }
  return updated.length > 0;
}
function renderProvider(element, container, provider, contexts) {
  if (provider === void 0) {
    provider = container.__CROACT__;
  }
  if (contexts === void 0) {
    contexts = {};
  }
  var isProvider = !!provider;
  if (!provider) {
    provider = new ContainerProvider(container);
  }
  var hooks = [];
  renderProviders(provider, provider._ps, element ? [element] : [], hooks, contexts, undefined, undefined);
  executeHooks(hooks);
  setCurrentInstance(null);
  if (!isProvider) {
    container.__CROACT__ = provider;
  }
  return provider;
}
function render(element, container, callback) {
  var provider = container.__CROACT__;
  if (element && !provider) {
    container.innerHTML = "";
  }
  renderProvider(element, container, provider);
  callback && callback();
}
function renderSelf(element, self, containerProvider) {
  if (!containerProvider && element) {
    containerProvider = new ContainerProvider(self.parentElement);
    containerProvider._hyd = [self];
    containerProvider._sel = true;
  }
  renderProvider(element, self, containerProvider);
  return containerProvider;
}

var i  = 0;
function createContext(defaultValue) {
  var id = "c".concat(++i);
  function Provider(props) {
    var self = this;
    if (!self.$_cs[id]) {
      self.$_cs[id] = self;
      var $_subs = [];
      self.shouldComponentUpdate = function (nextProps) {
        if (nextProps.value !== self.props.value) {
          // request
          self.$_req = true;
        }
      };
      self.render = function () {
        return self.props.children[0];
      };
      self.$_subs = $_subs;
    }
    return props.children[0];
  }
  function Consumer(props, contextValue) {
    return props.children(contextValue);
  }
  function getContext(provider) {
    return provider._cs[id];
  }
  var context = {
    $_id: id,
    $_dv: defaultValue,
    Consumer: Consumer,
    Provider: Provider,
    get: function (provider) {
      var _a, _b;
      return (_b = (_a = getContext(provider)) === null || _a === void 0 ? void 0 : _a.props.value) !== null && _b !== void 0 ? _b : defaultValue;
    },
    register: function (provider) {
      var mainComponent = getContext(provider);
      if (mainComponent) {
        utils.pushSet(mainComponent.$_subs, provider);
      }
    },
    unregister: function (provider) {
      var mainComponent = getContext(provider);
      if (mainComponent) {
        var subs = mainComponent.$_subs;
        var index = subs.indexOf(provider);
        if (index > -1) {
          subs.splice(index, 1);
        }
      }
    }
  };
  Consumer.contextType = context;
  return context;
}

var Portal = /*#__PURE__*/function (_super) {
  __extends(Portal, _super);
  function Portal() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = Portal.prototype;
  __proto.componentDidMount = function () {
    var self = this;
    var _a = self.props,
      element = _a.element,
      container = _a.container;
    var parentProvider = self.$_p;
    self._pp = new ContainerProvider(container, parentProvider.d + 1);
    renderProvider(element, container, self._pp, parentProvider._cs);
  };
  __proto.componentDidUpdate = function () {
    var self = this;
    var _a = self.props,
      element = _a.element,
      container = _a.container;
    renderProvider(element, container, self._pp, self.$_p._cs);
  };
  __proto.componentWillUnmount = function () {
    var self = this;
    var container = self.props.container;
    renderProvider(null, container, self._pp, self.$_p._cs);
    this._pp = null;
  };
  return Portal;
}(PureComponent);
function createPortal(el, container) {
  return createElement(Portal, {
    element: el,
    container: container
  });
}

function _renderToString(node, parentContexts, self) {
  if (node == null) {
    return "";
  }
  if (utils.isString(node) || utils.isNumber(node) || utils.isFunction(node)) {
    return node;
  }
  var type = node.type,
    props = node.props;
  if (utils.isString(type)) {
    var stringProps_1 = {};
    utils.getEntries(props).forEach(function (_a) {
      var name = _a[0],
        value = _a[1];
      if (name === "style") {
        stringProps_1[name] = utils.getEntries(value).map(function (_a) {
          var styleName = _a[0],
            styleValue = _a[1];
          return "".concat(utils.decamelize(styleName), ": ").concat(styleValue, ";");
        }).join("");
      } else if (name === "children") {
        return;
      } else if (!name.match(/^on[^a-z]/g)) {
        stringProps_1[name] = "".concat(value);
      }
    });
    var children = props.children.map(function (child) {
      return _renderToString(child, parentContexts);
    }).join("");
    if (self) {
      return {
        tagName: type,
        props: stringProps_1,
        children: children
      };
    }
    var strings = __spreadArray([type], utils.getEntries(stringProps_1).map(function (_a) {
      var name = _a[0],
        value = _a[1];
      return "".concat(name, "=\"").concat(value.replace(/"/g, "\\\""), "\"");
    }), true);
    return "<".concat(strings.join(" "), ">").concat(children, "</").concat(type, ">");
  } else if (utils.isFunction(type)) {
    var contextType = type.contextType;
    var provider = {
      b: null,
      _hs: [],
      _usefs: [],
      _uefs: [],
      _defs: [],
      _cs: parentContexts
    };
    setCurrentInstance(provider);
    var contextValue = contextType === null || contextType === void 0 ? void 0 : contextType.get(provider);
    var base = createComponent(type, props, contextValue, {});
    var nextContexts = __assign(__assign({}, parentContexts), base.$_cs);
    provider.b = base;
    return _renderToString(base.render(), nextContexts, self);
  }
  return "";
}
function renderToString(node) {
  return _renderToString(node, {});
}
function renderSelfToString(node) {
  return _renderToString(node, {}, true);
}

function checkHookInfo(info) {
  var inst = getCurrentInstance();
  var hooks = inst._hs || (inst._hs = []);
  var index = getHooksIndex();
  var prevHt = hooks[index];
  setHooksInex(index + 1);
  if (prevHt) {
    if (!isDiff(prevHt.deps, info.deps)) {
      prevHt.updated = false;
      return prevHt;
    }
    hooks[index] = info;
  } else {
    hooks.push(info);
  }
  info.value = info.func();
  info.updated = true;
  return info;
}
function useMemo(defaultFunction, deps) {
  var info = checkHookInfo({
    func: defaultFunction,
    deps: deps
  });
  return info.value;
}
function useRef(defaultValue) {
  return useMemo(function () {
    return createRef(defaultValue);
  }, []);
}
function useContext(context) {
  var inst = getCurrentInstance();
  var contextId = context.$_id;
  var contexts = inst._cs;
  var providerComponent;
  if (contextId in contexts) {
    providerComponent = contexts[contextId];
    providerComponent.props.value;
  } else {
    context.$_dv;
  }
  useEffect(function () {
    context.register(inst);
    return function () {
      context.unregister(inst);
    };
  }, []);
  return context.get(inst);
}
function useState(st) {
  var inst = getCurrentInstance();
  var index = getHooksIndex();
  var comp = inst.b;
  checkHookInfo({
    func: function () {
      comp.state[index] = utils.isFunction(st) ? st() : st;
    },
    deps: []
  });
  return [comp.state[index], function (nextValue) {
    var _a;
    return comp.setState((_a = {}, _a[index] = nextValue, _a));
  }];
}
function useEffect(effect, deps, unshift) {
  var inst = getCurrentInstance();
  var info = checkHookInfo({
    func: function () {
      return effect;
    },
    deps: deps
  });
  var effects = unshift ? inst._usefs : inst._uefs;
  if (info.updated) {
    effects.push(function () {
      info.effect && info.effect();
      info.effect = effect();
      return info.effect;
    });
  } else {
    effects.push(function () {
      return info.effect;
    });
  }
}
function useImperativeHandle(ref, func, deps) {
  useEffect(function () {
    ref === null || ref === void 0 ? void 0 : ref(func());
  }, deps, true);
}

var version = "simple-1.0.0";

exports.Component = Component;
exports.ContainerProvider = ContainerProvider;
exports.PureComponent = PureComponent;
exports.createContext = createContext;
exports.createElement = createElement;
exports.createPortal = createPortal;
exports.createRef = createRef;
exports.findDOMNode = findDOMNode;
exports.findNodeProvider = findNodeProvider;
exports.forwardRef = forwardRef;
exports.render = render;
exports.renderSelf = renderSelf;
exports.renderSelfToString = renderSelfToString;
exports.renderToString = renderToString;
exports.useContext = useContext;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useMemo = useMemo;
exports.useRef = useRef;
exports.useState = useState;
exports.version = version;
//# sourceMappingURL=croact.cjs.js.map
